# Bitrix24 App Development — Best Practices

Compiled from building [SYNITY] HTTP Request robot (2026-02).

## 1. Architecture Pattern

```
project/
  server.js              — Express routes + test endpoint
  install.js             — Robot/activity registration (bizproc.robot.add)
  update.js              — Update robot config (imports robotConfig from install.js)
  handlers/
    placementHandler.js  — Custom UI (inline HTML/CSS/JS in res.send)
    executeHandler.js    — Robot execution logic
    installHandler.js    — Install/uninstall lifecycle
  services/
    httpRequest.js       — External HTTP calls
    bitrixApi.js         — Bitrix REST API calls (bizproc.event.send, etc.)
  utils/
    logger.js            — Structured logging
    validation.js        — Input validation
```

Deploy: Railway (auto-deploy from `main` branch, binds to `0.0.0.0`).

## 2. Robot Registration (bizproc.robot.add)

```javascript
const robotConfig = {
  CODE: 'your_robot_code',           // Unique ID, no spaces
  HANDLER: process.env.HANDLER_URL + '/bitrix-handler/execute',
  AUTH_USER_ID: 1,
  NAME: { en: '[SYNITY] Your Robot', ru: '[SYNITY] Ваш Робот' },
  USE_PLACEMENT: 'Y',                // Enable custom UI
  PLACEMENT_HANDLER: process.env.HANDLER_URL + '/placement/robot-settings',
  PROPERTIES: {
    config: { Name: 'Config', Type: 'text' }  // Single JSON property
  },
  RETURN_PROPERTIES: {
    output_1: { Name: 'Output 1', Type: 'text' },
    // ... up to output_N
  }
};
```

Key points:
- `USE_PLACEMENT: 'Y'` enables custom settings UI iframe
- Use a single `config` property (Type: text) with JSON for complex config
- `RETURN_PROPERTIES` must be registered upfront to use output values in next rules

## 3. Placement Handler (Custom UI)

### Data Flow
1. User opens robot settings → Bitrix POSTs to PLACEMENT_HANDLER
2. Server reads `req.body.PLACEMENT_OPTIONS` → parse JSON → get `current_values.config`
3. Server renders HTML with saved config pre-injected: `window.__SAVED_CONFIG__ = ${JSON.stringify(savedConfig)}`
4. Client loads BX24 JS SDK: `<script src="//api.bitrix24.com/api/v1/"></script>`
5. On every input change → `BX24.placement.call('setPropertyValue', { config: jsonString })`
6. User clicks Bitrix's own SAVE button → done

### Save Pattern (Critical)
```javascript
// Debounced save for oninput (while typing)
function saveToPlacement() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(doSave, 150);
}

// Immediate save for onchange (blur) and structural changes
function flushSave() {
  clearTimeout(saveTimeout);
  doSave();
}

function doSave() {
  var config = getCurrentConfig();           // Read from DOM directly
  config = convertConfigDisplayNames(config); // Convert {{Display}} → {=Document:CODE}
  var configString = JSON.stringify(config);
  if (configString === lastSavedConfig) return;
  lastSavedConfig = configString;
  BX24.placement.call('setPropertyValue', { config: configString });
}
```

### Variable Picker
- Read `PLACEMENT_OPTIONS.document_fields` → map `FIELD_CODE → Display Name`
- Insert `{=Document:FIELD_CODE}` into inputs
- **Display name gotcha**: Bitrix converts `{=Document:CRM_ID}` → `{{CRM item ID}}` in saved values. Must convert back before saving using reverse map.

### Only Supported Command
`BX24.placement.call('setPropertyValue', {...})` — this is the ONLY command that works for robot placement. No finish/saveSettings/bindEvent.

## 4. Execute Handler

```javascript
async function executeHandler(req, res) {
  const { event_token, properties, auth } = req.body;

  // Parse config from single JSON property
  let config = properties;
  if (properties.config) {
    config = JSON.parse(properties.config);
  }

  // ... do work ...

  // Send results back
  await sendBizprocEvent({
    event_token,
    return_values: { output_1: 'value', ... },
    log_message: 'Success message',
    auth
  });

  res.json({ success: true });
}
```

Key: Bitrix resolves `{=Document:CODE}` variables in text properties BEFORE calling your handler. You receive actual values.

## 5. Output Values Between Rules

- Register `RETURN_PROPERTIES` with `bizproc.robot.add`
- Set values in `return_values` of `bizproc.event.send`
- Next rule MUST use **"After previous rule"** execution mode (not "In parallel")
- Variable syntax in next rule: `{{~ActivityId:output_1}}` (auto-generated by Bitrix UI)

## 6. Test Endpoint Pattern

Useful for previewing API responses without running a real workflow:
```javascript
app.post('/bitrix-handler/test', async (req, res) => {
  const { config } = req.body;
  // Reuse same buildRequestHeaders/buildRequestBody/extractJsonPath
  // Return: { success, statusCode, responseBodyParsed, outputMappings, executionTime }
});
```

## 7. UI Design (b24ui Alignment)

Design tokens from https://bitrix24.github.io/b24ui:
- Primary: `#0075ff`, Danger: `#ff5752`, Success: `#1bce7b`, Warning: `#faa72c`
- Text: `#333` / `#525c69` / `#a8adb4`, Border: `#edeef0`, Page bg: `#eef2f4`
- Input: height 32px, padding 7px 12px, radius 4px, font 13px
- Focus: `box-shadow: 0 0 0 3px rgba(0, 117, 255, 0.15)`
- Font: `system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', ...`

Compact placement UI tips:
- Flatten nested borders — no boxed sections inside boxed sections
- Section titles: 13px uppercase muted instead of boxed headers
- Minimize vertical space — placement iframe is very short
- Use tabs for grouping, not accordion or stacked sections

## 8. Bitrix24 JS SDK (@bitrix24/b24jssdk)

Modern TypeScript-first SDK (v1.0.1). Docs: https://bitrix24.github.io/b24jssdk

### Three Core Classes

| Class | Environment | Auth | Use Case |
|-------|------------|------|----------|
| `B24Frame` | Client iframe | Auto (parent frame token) | Embedded apps (placement UI) |
| `B24Hook` | Server (Node.js) | Webhook secret | CLI scripts, server tools |
| `B24OAuth` | Server (Node.js) | OAuth 2.0 + auto-refresh | Production server apps |

### REST API Calls (same interface for all 3 classes)

```typescript
// Single call
const resp = await $b24.actions.v2.call.make({
  method: 'crm.deal.get', params: { id: 123 }
})

// Auto-paginated list (fetches ALL pages)
const resp = await $b24.actions.v2.callList.make({
  method: 'crm.deal.list',
  params: { select: ['ID', 'TITLE'], order: { ID: 'ASC' } },
  idKey: 'ID'
})

// Streaming large lists (AsyncGenerator, memory-efficient)
for await (const chunk of $b24.actions.v2.fetchList.make({ ... })) { }

// Batch (auto-chunks unlimited commands into 50-per-request)
await $b24.actions.v2.batchByChunk.make({ calls: hundredsOfCommands })
```

### Placement (B24Frame)

```typescript
const $b24 = await initializeB24Frame()
$b24.placement.placement    // 'DEFAULT', 'CRM_DEAL_DETAIL_TAB', etc.
$b24.placement.options      // PLACEMENT_OPTIONS
await $b24.placement.call('setPropertyValue', { config: jsonStr })
```

### When to Use New SDK vs Legacy

| Scenario | Recommendation |
|----------|---------------|
| Simple placement UI (inline HTML) | Legacy `BX24` via script tag — simpler |
| Vue/React placement app | `B24Frame` from b24jssdk |
| Server-side Bitrix API calls | `B24Hook` or `B24OAuth` — typed, auto-pagination |
| CLI scripts with webhook | `B24Hook` — cleaner than raw axios |

Reference: See `B24JSSDK-REFERENCE.md` in memory for full API details.

## 9. b24ui Design System

Vue component library for Bitrix24 UI. Docs: https://bitrix24.github.io/b24ui

Key tokens for non-Vue (plain HTML) apps — see Section 7 above.

For Vue apps: install `@bitrix24/b24ui`, use components like `<B24Input>`, `<B24Button>`, `<B24Card>`, `<B24FormField>` with size="sm" for compact placement UIs.

Reference: See `B24UI-DESIGN-SYSTEM.md` in memory for full token/component details.

## 10. Admin Page (App Management UI)

### Architecture
```
Bitrix24 Left Menu → POST /admin → Express serves Vue SPA with injected auth
Vue SPA → fetch /api/admin/* → Express API → PostgreSQL
Robot Execute → quota check → HTTP request → log to DB (fire-and-forget)
```

### Admin Page Entry Point
Bitrix24 POSTs to your app URL when user opens from left menu. The POST body contains:
- `AUTH_ID`, `REFRESH_ID`, `member_id`, `PLACEMENT`, `PLACEMENT_OPTIONS`
- **DOMAIN may be missing** — extract from `Referer` header or env var fallback

```javascript
app.post('/admin', async (req, res) => {
  const { AUTH_ID, REFRESH_ID, member_id } = req.body;
  // Domain fallback chain: POST body > Referer header > env var
  let domain = req.body.DOMAIN || '';
  if (!domain && req.headers.referer) {
    domain = new URL(req.headers.referer).hostname;
  }
  if (!domain) domain = process.env.BITRIX24_DOMAIN || '';

  // Read built SPA, inject auth context
  let html = fs.readFileSync('admin-ui/dist/index.html', 'utf8');
  const authScript = `<script>window.__B24_AUTH__=${JSON.stringify({
    domain, authId: AUTH_ID, memberId: member_id
  })};</script>`;
  html = html.replace('</head>', authScript + '</head>');
  res.type('html').send(html);
});
```

### Auth Middleware for Admin API
- SPA sends `X-Member-Id`, `X-Auth-Id`, `X-Domain` headers on every API call
- Middleware verifies via `https://{domain}/rest/app.info?auth={authId}`
- Cache verification 5 minutes per member_id

### Quota Enforcement (Fail-Open)
```javascript
// In executeHandler — BEFORE making HTTP request
const quota = await checkQuota(memberId, domain);
if (!quota.allowed) {
  await sendBizprocEvent({ event_token, return_values: { error: 'Quota exceeded' }, auth });
  return;
}
// ... make request ...
// After: fire-and-forget log
logRequest({ accountId, url, method, statusCode, success, executionTime });
```

Key: DB errors never block robot execution (fail-open). Request logging is fire-and-forget.

### Vue SPA in Bitrix24 Iframe
- **Hash-mode routing** (`createWebHashHistory`) — required for iframe
- **Vite base**: `/admin-assets/` — static assets served separately
- **Auth**: `window.__B24_AUTH__` injected server-side, read by composable
- **No BX24 SDK needed** — auth token passed directly from server

### Railway Deployment Gotcha: Nixpacks COPY
Nixpacks always runs `COPY . /app` as the LAST step, overwriting any files built during earlier build steps. **Solution: commit `admin-ui/dist/` to git** so it survives the final COPY.

Do NOT use `buildCommand` in railway.json for this — it runs before COPY.

### Database Setup
- PostgreSQL on Railway: `railway add --database postgres`
- Set `DATABASE_URL` on app service referencing internal Postgres URL
- Migrations: `railway run npm run migrate`
- Seed: `node db/seed.js` with public DATABASE_URL

### Pricing / Quota Model
```javascript
const PLAN_LIMITS = {
  free: 100, basic: 1000, pro: 10000, enterprise: Infinity
};
```
Identify users by `member_id` (unique per Bitrix24 portal). Store domain for display.
Owner/developer account: set to `enterprise` plan in DB.

## 11. Common Pitfalls

| Pitfall | Solution |
|---------|----------|
| setPropertyValue not saving | Call on every change, not just Save button |
| Config lost on reopen | Server must read PLACEMENT_OPTIONS and pre-render values |
| Variables show display names | Build reverse map from document_fields, convert before save |
| Output values empty in next rule | Use "After previous rule" mode, not "In parallel" |
| Test mode shows raw variables | Expected — variables resolve only in real workflow |
| OAuth token expired in CLI | Auto-refresh: check expiry, call oauth.bitrix.info/oauth/token |
| Admin POST missing DOMAIN | Extract from Referer header, then env var fallback |
| Nixpacks overwrites build output | Commit dist/ to git — COPY runs after build steps |
| Admin API 401 in iframe | Inject auth via `window.__B24_AUTH__` server-side, send as X-headers |
| DB down during robot execution | Fail-open: catch errors, allow request, log warning |
